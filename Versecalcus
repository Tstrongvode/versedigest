General descritpions

    Verse is a functional logic language (like Curry or Mercury)
    Verse is a declarative language: a variable names a single value, not a cell whose value changes over time
    Verse is lenient but not strict:
    Like strict: everything gets evaluated in the end
    Like lazy: functions can be called before the argument has a value
    Verse has an unusual static type system: types are firstclass values
    Verse has an effect system, rather than using monads
    Verse is open: Open spec, open-source compiler, verifier, published papers, runtime under permissive open-source license with no IP encumberances
    Mutable state, I/O, and other effects
    Pervasive transactional memory
    Structs, classes, inheritance

Ideas & visions

    Kick functional logic programming out the lab and into the mainstream

    Learnable as a first language (c.f. Javascript yes, C++ no)

    Stretches from end users to professional developers

    Transactional memory at scale

    Very strong stability guarantees

    A radical new approach to types

    Extensible: mechanisms for the language to grow over time, without breaking code


2402
2403
2404
2405
2406
2407
2408
2409
2410
2411
2412
2413
2414
2415
2416
2417
2418
2419
2420
2421
2422
2423
2424
2425
2426
2427
2428
2429
2430
2431
2432
2433
2434
2435
2436
2437
2438
2439
2440
2441
2442
2443
2444
2445
2446
2447
2448
2449
2450
In submission, March 2023,
Augustsson, Breitner, Claessen, Jhala, Peyton Jones, Shivers, Steele, Sweeney
can never again be used to perform a substitution in that block unless new occurrences of ğ‘¥ are
injected into the block by a substitution performed in an enclosing block, in which case, the block
metric for the outer block will be strictly smaller. Specifically, each application of
â€¢ choose strictly reduces â™¯choose;
â€¢ seq-assoc or eqn-float strictly reduces â™¯semi (leaving â™¯choose unchanged);
â€¢ subst strictly reduces â™¯cands (leaving â™¯semi, â™¯choose unchanged), as it eliminates a variable
from the block â„“ that the substitution spans;
â€¢ u-tup strictly reduces size (leaving cands, â™¯semi, â™¯choose unchanged), as it preserves elim
and hence cand, but reduces the size of â„“;
â€¢ u-lit, u-fail, u-occurs strictly reduces size (leaving cands, â™¯semi, â™¯choose unchanged);
â€¢ var-swap strictly reduces swaps leaving the other components unchanged.
Thus, as â™¯(ğœğ‘–, ğ‘ğ‘– ) is a strictly decreasing well-founded metric, the sequence (ğœ1, ğ‘1), . . . , is finite,
and so any sequence of U0â€™ steps is guaranteed to terminate. â–¡
Lemma C.27. U0 is Noetherian for all tails ğ‘¡, rhs ğ‘Ÿ and expressions ğ‘’.
Proof. By induction on the structure of t, r and e, using Lemma C.26 for the base case. â–¡
Lemma C.28. U is locally confluent.
Proof. Let Î”1 âˆ’â†’1 Î”â€²
1 and Î”2 âˆ’â†’2 Î”â€²
2 denote the two U reducts. If the reducts are disjoint, then
the terms can be joined trivially in a single step via Lemma C.4. By symmetry it suffices to consider
the case where Î”1 occurs under Î”2. Let us split cases on the rule used for Î”1.
Case Î”1 via U âˆ’ subst âˆ’ var-swap join using Lemma C.6.
Case Î”1 via var-swap join using Lemma C.29.
Case Î”1 via subst join using Lemma C.30.
â–¡
Lemma C.29 (var-swap under). If Î”U âˆ’â†’U Î”â€²
U and Î”U â‰¡ ğ¸ [Î”] and Î” âˆ’â†’swap Î”â€² then there
exists Î”â€²â€²
U such that Î”â€²
U âˆ’â†’â†’swap Î”â€²â€²
U and ğ¸ [Î”â€²] âˆ’â†’U Î”â€²â€²
R .
Î”U â‰¡ ğ¸ [Î”] ğ¸ [Î”â€²]
Î”â€²
U Î”â€²â€²
U
U
var-swap
U
var-swap
Proof. Split cases on the rule used in U.
Case u-lit or var-swap : impossible as no var-swap redex under k1 = k2 or x = y.
Case u-tup : Here, Î”U â‰¡ âŸ¨u1,. . ., unâŸ© = âŸ¨v1,. . ., vnâŸ© and wlog the var-swap redex is ğ‘¢â€²
1 âˆ’â†’ğ‘¢1 so
join at u_1â€² = v1; . . .; un = vn.
Case u-fail : Here, Î”U â‰¡ hnf ğ‘– âˆ’â†’ hnf â€²
ğ‘– so join at fail
Case u-occurs : Here, Î”U â‰¡ x = V [ x ] and the var-swap redex is under V [ x ], i.e. ğ‘‰ [ğ‘¥] âˆ’â†’subst
ğ‘‰ [ğ‘¥]â€² as the free variables are preserved by var-swap hence we can join at fail.
Case hnf-swap : Here, Î”U â‰¡ hnf = ğ‘¥ and the var-swap redex is under hnf i.e. hnf âˆ’â†’subst
hnf â€², hence join at ğ‘¥ = hnf â€².
Case subst : via Lemma C.12.
Case choose : via Lemma C.7.
Case seq-assoc : Here, Î”U â‰¡ (ğ‘’ğ‘; ğ‘’1); ğ‘’2 âˆ’â†’ ğ‘’ğ‘; (ğ‘’1; ğ‘’2) â‰¡ Î”â€²
U . Split cases on where Î” occurs.
Case Î” âŠ† ğ‘’ğ‘ i.e. ğ‘’ğ‘ âˆ’â†’var-swap ğ‘’ğ‘¢â€² Join at Î”â€²â€²
U â‰¡ ğ‘’ğ‘¢â€²; (ğ‘’1; ğ‘’2).
Case Î” âŠ† ğ‘’1 i.e. ğ‘’1 âˆ’â†’var-swap ğ‘’â€²
1 Join at Î”â€²â€²
U â‰¡ ğ‘’ğ‘; (ğ‘’â€²
1; ğ‘’2).
50
2451
2452
2453
2454
2455
2456
2457
2458
2459
2460
2461
2462
2463
2464
2465
2466
2467
2468
2469
2470
2471
2472
2473
2474
2475
2476
2477
2478
2479
2480
2481
2482
2483
2484
2485
2486
2487
2488
2489
2490
2491
2492
2493
2494
2495
2496
2497
2498
2499
The Verse Calculus: a Core Calculus for Functional Logic Programming
In submission, March 2023,
Case Î” âŠ† ğ‘’2 i.e. ğ‘’2 âˆ’â†’var-swap ğ‘’â€²
2 Join at Î”â€²â€²
U â‰¡ ğ‘’ğ‘; (ğ‘’1; ğ‘’â€²
2).
Case eqn-float : Î”U â‰¡ ğ‘£ = (ğ‘’ğ‘; ğ‘’1); ğ‘’2 âˆ’â†’ ğ‘’ğ‘; (ğ‘£ = ğ‘’1; ğ‘’2) â‰¡ Î”â€²
U . Split cases on where Î” occurs.
Case Î” âŠ† ğ‘£ i.e. ğ‘£ âˆ’â†’var-swap ğ‘£ â€² Join at Î”â€²â€²
U â‰¡ ğ‘’ğ‘; (ğ‘£ â€² = ğ‘’1; ğ‘’2).
Case Î” âŠ† ğ‘’ğ‘ i.e. ğ‘’ğ‘ âˆ’â†’var-swap ğ‘’ğ‘¢â€² Join at Î”â€²â€²
U â‰¡ ğ‘’ğ‘¢â€²; (ğ‘£ = ğ‘’1; ğ‘’2).
Case Î” âŠ† ğ‘’1 i.e. ğ‘’1 âˆ’â†’var-swap ğ‘’â€²
1 Join at Î”â€²â€²
U â‰¡ ğ‘’ğ‘; (ğ‘£ = ğ‘’â€²
1; ğ‘’2).
Case Î” âŠ† ğ‘’2 i.e. ğ‘’2 âˆ’â†’var-swap ğ‘’â€²
2 Join at Î”â€²â€²
U â‰¡ ğ‘’ğ‘; (ğ‘£ = ğ‘’1; ğ‘’â€²
2).
â–¡
Lemma C.30 (subst-under). If Î”U âˆ’â†’U Î”â€²
U and Î”U â‰¡ ğ¸ [Î”] and Î” âˆ’â†’subst Î”â€² then there exists
Î”â€²â€²
U such that Î”â€²
U âˆ’â†’â†’subst Î”â€²â€²
U and ğ¸ [Î”â€²] âˆ’â†’U Î”â€²â€²
U .
Î”U â‰¡ ğ¸ [Î”] ğ¸ [Î”â€²]
Î”â€²
U Î”â€²â€²
U
U
subst
U
subst
Proof. Split cases on the rule used in U.
Case u-lit or var-swap : impossible as no subst redex under k1 = k2 or x = y.
Case u-tup : Here, Î”U â‰¡ âŸ¨u1,. . ., unâŸ© = âŸ¨v1,. . ., vnâŸ© and wlog the subst redex is ğ‘¢â€²
1 âˆ’â†’ğ‘¢1 so join at
u_1â€² = v1; . . .; un = vn.
Case u-fail : Here, Î”U â‰¡ hnf ğ‘– âˆ’â†’ hnf â€²
ğ‘– so join at fail
Case u-occurs : Here, Î”U â‰¡ x = V [ x ] and the subst redex is under V [ x ], i.e. ğ‘‰ [ğ‘¥] âˆ’â†’subst
ğ‘‰ [ğ‘¥]â€² as the free variables are preserved by subst hence we can join at fail.
Case hnf-swap : Here, Î”U â‰¡ hnf = ğ‘¥ and the subst redex is under hnf i.e. hnf âˆ’â†’subst hnf â€²,
hence join at ğ‘¥ = hnf â€².
Case subst : via Lemma C.14.
Case choose : via Lemma C.7.
Case seq-assoc : Î”U â‰¡ (ğ‘’ğ‘; ğ‘’1); ğ‘’2 âˆ’â†’ ğ‘’ğ‘; (ğ‘’1; ğ‘’2) â‰¡ Î”â€²
U . Split cases on where Î” occurs.
Case Î” âŠ† ğ‘’ğ‘ i.e. ğ‘’ğ‘ âˆ’â†’Râ€² ğ‘’ğ‘¢â€² Join at Î”â€²â€²
U â‰¡ ğ‘’ğ‘¢â€²; (ğ‘’1; ğ‘’2).
Case Î” âŠ† ğ‘’1 i.e. ğ‘’1 âˆ’â†’Râ€² ğ‘’â€²
1 Join at Î”â€²â€²
U â‰¡ ğ‘’ğ‘; (ğ‘’â€²
1; ğ‘’2).
Case Î” âŠ† ğ‘’2 i.e. ğ‘’2 âˆ’â†’Râ€² ğ‘’â€²
2 Join at Î”â€²â€²
U â‰¡ ğ‘’ğ‘; (ğ‘’1; ğ‘’â€²
2).
Case Î” âŠ† (ğ‘’ğ‘; ğ‘’1) i.e. subst : (ğ‘’ğ‘; ğ‘’1) âˆ’â†’ (ğ‘’ğ‘¢â€²; ğ‘’â€²
1) Join at Î”â€²â€²
U â‰¡ ğ‘’ğ‘¢â€²; (ğ‘’â€²
1; ğ‘’2).
Case Î” âŠ† ((ğ‘’ğ‘; ğ‘’1); ğ‘’2) i.e. subst : (ğ‘’ğ‘; ğ‘’1); ğ‘’2 âˆ’â†’ (ğ‘’ğ‘¢â€²; ğ‘’â€²
1); ğ‘’â€²
2 Join at Î”â€²â€²
U â‰¡ ğ‘’ğ‘¢â€²; (ğ‘’â€²
1; ğ‘’â€²
2).
Case eqn-float : Î”U â‰¡ ğ‘£ = (ğ‘’ğ‘; ğ‘’1); ğ‘’2 âˆ’â†’ ğ‘’ğ‘; (ğ‘£ = ğ‘’1; ğ‘’2) â‰¡ Î”â€²
U . Split cases on where Î” occurs.
Case Î” âŠ† ğ‘£ i.e. ğ‘£ âˆ’â†’Râ€² ğ‘£ â€² Join at Î”â€²â€²
U â‰¡ ğ‘’ğ‘; (ğ‘£ â€² = ğ‘’1; ğ‘’2).
Case Î” âŠ† ğ‘’ğ‘ i.e. ğ‘’ğ‘ âˆ’â†’Râ€² ğ‘’ğ‘¢â€² Join at Î”â€²â€²
U â‰¡ ğ‘’ğ‘¢â€²; (ğ‘£ = ğ‘’1; ğ‘’2).
Case Î” âŠ† ğ‘’1 i.e. ğ‘’1 âˆ’â†’Râ€² ğ‘’â€²
1 Join at Î”â€²â€²
U â‰¡ ğ‘’ğ‘; (ğ‘£ = ğ‘’â€²
1; ğ‘’2).
Case Î” âŠ† ğ‘’2 i.e. ğ‘’2 âˆ’â†’Râ€² ğ‘’â€²
2 Join at Î”â€²â€²
U â‰¡ ğ‘’ğ‘; (ğ‘£ = ğ‘’1; ğ‘’â€²
2).
Case Î” âŠ† (ğ‘’ğ‘; ğ‘’1) i.e. subst : ğ‘£ = (ğ‘’ğ‘; ğ‘’1); ğ‘’2 âˆ’â†’ ğ‘£ = (ğ‘’ğ‘¢â€²; ğ‘’â€²
1); ğ‘’2. Join at Î”â€²â€²
U â‰¡ ğ‘’ğ‘¢â€²; (ğ‘£ =
ğ‘’â€²
1; ğ‘’2).
Case Î” âŠ† ğ‘£ = (ğ‘’ğ‘; ğ‘’1); ğ‘’2 i.e. subst : (ğ‘£ = ğ‘’ğ‘; ğ‘’1); ğ‘’2 âˆ’â†’ (ğ‘£ â€² = ğ‘’ğ‘¢â€²; ğ‘’â€²
1); ğ‘’â€²
2 Join at Î”â€²â€²
U â‰¡
ğ‘’ğ‘¢â€²; (ğ‘£ â€² = ğ‘’â€²
1; ğ‘’â€²
2).
â–¡
C.5 Normalization is Confluent
Recall that N â‰¡ exi-swap + exi-float + var-swap + subst-var where
subst-var ğ‘‹ [ x = y; e ] âˆ’â†’ (ğ‘‹ {y/x}) [ x = y; e{y/x} ]
51
2500
2501
2502
2503
2504
2505
2506
2507
2508
2509
2510
2511
2512
2513
2514
2515
2516
2517
2518
2519
2520
2521
2522
2523
2524
2525
2526
2527
2528
2529
2530
2531
2532
2533
2534
2535
2536
2537
2538
2539
2540
2541
2542
2543
2544
2545
2546
2547
2548
In submission, March 2023,
Augustsson, Breitner, Claessen, Jhala, Peyton Jones, Shivers, Steele, Sweeney
It will be convenient to factor out exi-float so let
SS  subst-var + var-swap
N â€²  SS + exi-swap
N  N â€² + exi-float
Lemma C.31 (N-Confluent). N is confluent.
Proof. The above result follows in two steps. First we show that N â€²â€“ i.e. normalization-without-
exi-float â€“ is confluent in Lemma C.35. Second we show that N â€²strongly postpones after exi-
float Lemma C.34. Consequently, each âˆ’â†’â†’N can be rewritten as the composition of âˆ’â†’â†’exi-float
followed by âˆ’â†’â†’Nâ€² after which the following diagram completes the proof, where (1) Lemma C.32
(2) Lemma C.33 (3) Lemma C.35. (4) Lemma C.35
â€¢
â€¢ â€¢
â€¢ â€¢
â€¢ (1) â€¢
(2) (2)
(3) (3)
(4)
exi-float exi-float
exi-float exi-float
Nâ€² Nâ€²
Nâ€²
Nâ€² Nâ€²
Nâ€²
Nâ€² Nâ€²
Nâ€²
Nâ€²
exi-float
Nâ€²
exi-float
â–¡
Lemma C.32. If ğ‘’ âˆ’â†’â†’exi-float ğ‘’1 and ğ‘’ âˆ’â†’â†’exi-float ğ‘’2 then exists ğ‘’1 âˆ’â†’â†’exi-float ğ‘’â€²
1, ğ‘’2 âˆ’â†’â†’exi-float
ğ‘’â€²
2, such that ğ‘’â€²
1 â†“exi-swap ğ‘’â€²
2.
Proof. On each side add the (missing) exi-float steps on the other side, and then use (multiple)
exi-swap to join. â–¡
Lemma C.33. exi-float strongly commutes with N â€².
Proof. Split cases on each possible case of N â€², the diamond is completed trivially as the rules
are non-overlapping. â–¡
Lemma C.34. N â€²strongly postpones after exi-float, so Nâˆ— â‰¡ exi-floatâˆ— Â· N â€²âˆ—.
Proof. Split cases on each possible case of N â€²; the diamond is completed trivially as the rules
are non-overlapping. â–¡
Lemma C.35. N â€²is confluent.
52
2549
2550
2551
2552
2553
2554
2555
2556
2557
2558
2559
2560
2561
2562
2563
2564
2565
2566
2567
2568
2569
2570
2571
2572
2573
2574
2575
2576
2577
2578
2579
2580
2581
2582
2583
2584
2585
2586
2587
2588
2589
2590
2591
2592
2593
2594
2595
2596
2597
The Verse Calculus: a Core Calculus for Functional Logic Programming
In submission, March 2023,
Proof. Via the following diagram, where: (1) is Lemma C.36; (2) is Lemma C.40; (3) is Lemma C.39;
(4) is Lemma C.38.
â€¢
â€¢ â€¢ â€¢ â€¢
(1) (4) (1)
(2) (2)
(3)
Nâ€² Nâ€²
ğ¸ ğ¸
S SS S S S S Sğ¸ ğ¸
S S S SNâ€² Nâ€²
S S S S
â–¡
Lemma C.36. If ğ‘’ âˆ’â†’â†’Nâ€² ğ‘’â€² there exists ğ‘’â€²â€² such that ğ‘’â€² âˆ’â†’â†’S S ğ‘’â€²â€² and ğ‘’ âˆ’â†’â†’exi-swap Â· âˆ’â†’â†’S S ğ‘’â€²â€².
ğ‘’ ğ‘’â€²
â€¢ ğ‘’â€²â€²
exi-swap
S S
S S
Nâ€²
Proof. By using Lemma B.25 with the facts that SS is confluent (Lemma C.39) and SS hops
after exi-swap (Lemma C.37). â–¡
Lemma C.37. SS(resp. U) hops after exi-swap.
Proof. By splitting cases on the SS(resp. U) reduction that precedes the exi-swap.
Case var-swap Let the Î”swap â‰¡ ğ‘‹ [ x = y ]. If the exi-swap preserves the order of ğ‘¥ and ğ‘¦ then
the result follows trivially (as the reductions are non-overlapping.) If the exi-swap toggles the
order then the result follows via the diagram
âˆƒğ‘¥, ğ‘¦. . . . ğ‘‹ [ğ‘¥ = ğ‘¦] âˆƒğ‘¥, ğ‘¦. . . . ğ‘‹ [ğ‘¦ = ğ‘¥]
âˆƒğ‘¦, ğ‘¥ . . . . ğ‘‹ [ğ‘¥ = ğ‘¦] âˆƒğ‘¦, ğ‘¥ . . . . ğ‘‹ [ğ‘¦ = ğ‘¥]
exi-swap
var-swap
exi-swap
var-swap
Case non-var-swap An U reduction other than var-swap is variable-order independent, so the
sequence of U-step followed by exi-swap is equivalent to first doing the exi-swap and then
the Ustep.
â–¡
Lemma C.38. exi-swap is confluent.
Proof. Trivial, via the diamond property. â–¡
Lemma C.39. SS = subst-var + swap is confluent.
Proof. Note that SS is a subset of U; the proof follows similar to the proof of Lemma C.19
(ignoring the bits about u-tup and u-lit and u-fail and substituting HNF values.) â–¡
Lemma C.40. SScommutes with N â€².
53
2598
2599
2600
2601
2602
2603
2604
2605
2606
2607
2608
2609
2610
2611
2612
2613
2614
2615
2616
2617
2618
2619
2620
2621
2622
2623
2624
2625
2626
2627
2628
2629
2630
2631
2632
2633
2634
2635
2636
2637
2638
2639
2640
2641
2642
2643
2644
2645
2646
In submission, March 2023,
Augustsson, Breitner, Claessen, Jhala, Peyton Jones, Shivers, Steele, Sweeney
Proof. Recall that N â€² â‰¡ SS + exi-swap. The proof follows by observing that SS half-commutes
with exi-swap Lemma C.41, recalling that SS is confluent Lemma C.39, after which Lemma B.27
yields the conclusion SS commutes with SS + exi-swap â‰¡ N â€². â–¡
Lemma C.41. SS half-commutes with exi-swap.
Proof. Recall that SS â‰¡ subst-var + var-swap. Split cases and show each reduction half-
commutes with exi-swap.
Case subst-var If the exi-swap occurs under subst-var then they trivially commute as the
variable order is unaffected by the exi-swap. If the subst-var occurs under exi-swap the proof
is completed by the following diagram.
âˆƒğ‘¦, ğ‘¥ . . . . ğ‘‹ [ğ‘¥ = ğ‘¦] âˆƒğ‘¥, ğ‘¦. . . . ğ‘‹ [ğ‘¥ = ğ‘¦]
âˆƒğ‘¥, ğ‘¦. . . . ğ‘‹ [ğ‘¦ = ğ‘¥]
âˆƒğ‘¦, ğ‘¥ . . . . ğ‘‹ {ğ‘¦/ğ‘¥ }[ğ‘¥ = ğ‘¦] âˆƒğ‘¥, ğ‘¦. . . . ğ‘‹ {ğ‘¦/ğ‘¥ }[ğ‘¥ = ğ‘¦] âˆƒğ‘¥, ğ‘¦. . . . ğ‘‹ {ğ‘¥/ğ‘¦}[ğ‘¦ = ğ‘¥]
exi-swap
var-swap
subst-var
subst-var
exi-swap var-swap+subst-var
Case var-swap (under exi-swap) The non-trivial cases are where the same variables ğ‘¥, ğ‘¦ are
being swapped by both rules (otherwise, the reductions half-commutes trivially via the
diamond property). For the variables to be the same, the var-swap must occur under the
exi-swap (as otherwise the same variables are not in scope.) Hence, the proof is completed by
the following diagram.
âˆƒğ‘¥, ğ‘¦. . . . ğ‘‹ [ğ‘¥ = ğ‘¦] âˆƒğ‘¦, ğ‘¥ . . . . ğ‘‹ [ğ‘¥ = ğ‘¦]
âˆƒğ‘¥, ğ‘¦. . . . ğ‘‹ [ğ‘¦ = ğ‘¥] âˆƒğ‘¦, ğ‘¥ . . . . ğ‘‹ [ğ‘¦ = ğ‘¥]
var-swap
exi-swap
var-swap
exi-swap
â–¡
C.6 Unification + Normalization is Confluent
Recall that
N  exi-float + exi-swap + SS
and define
Uâ€²  U + exi-swap
Lemma C.42. U âˆª N is confluent.
Proof. We prove UâˆªN is confluent by a generalization of the proof of Lemma C.31 where we use
the full U relation (instead of the subset SS). First we show that Uâ€™ â€“ i.e. U âˆª N without-exi-float
â€“ is confluent Lemma C.45. Second we show that Uâ€™ strongly postpones after exi-float Lemma C.44.
Consequently, each âˆ’â†’â†’UâˆªN can be rewritten as the composition of âˆ’â†’â†’exi-float followed by âˆ’â†’â†’Uâ€²
54
2647
2648
2649
2650
2651
2652
2653
2654
2655
2656
2657
2658
2659
2660
2661
2662
2663
2664
2665
2666
2667
2668
2669
2670
2671
2672
2673
2674
2675
2676
2677
2678
2679
2680
2681
2682
2683
2684
2685
2686
2687
2688
2689
2690
2691
2692
2693
2694
2695
The Verse Calculus: a Core Calculus for Functional Logic Programming
In submission, March 2023,
after which the following diagram completes the proof.
â€¢
â€¢ â€¢
â€¢ â€¢
â€¢ â€¢ â€¢
â€¢ â€¢
â€¢ â€¢
â€¢
exi-float exi-float
exi-float exi-float
Uâ€² Uâ€²
Uâ€²
Uâ€² Uâ€²
Uâ€²
Uâ€² Uâ€²
ğ¿ğ‘’ğ‘šğ‘šğ‘ ğ¶.32
ğ¿ğ‘’ğ‘šğ‘šğ‘ ğ¶.45
Uâ€²
exi-float
Uâ€²
ğ¿ğ‘’ğ‘šğ‘šğ‘ ğ¶.43
ğ¿ğ‘’ğ‘šğ‘šğ‘ ğ¶.45
Uâ€²
exi-float
ğ¿ğ‘’ğ‘šğ‘šğ‘ ğ¶.43
Uâ€²
ğ¿ğ‘’ğ‘šğ‘šğ‘ ğ¶.45
â–¡
Lemma C.43. exi-float strongly commutes with Uâ€™.
Proof. Split cases on each possible case of Uâ€™; the diamond is completed trivially as the rules
are non-overlapping. â–¡
Lemma C.44. Let Uâ€²  U +exi-swap. Ustrongly postpones after exi-float, so Uâ€²âˆ— â‰¡ exi-floatâˆ— Â·Uâˆ—.
Proof. Same as Lemma C.34. â–¡
Lemma C.45. Let Uâ€²  U + exi-swap. Uâ€² is confluent.
Proof. Via the following diagram, where: (1) is Lemma C.46; (2) is Lemma C.47; (3) is Lemma C.19;
(4) is Lemma C.38.
â€¢
â€¢ â€¢ â€¢ â€¢
(1) (4) (1)
(2) (2)
(3)
Uâ€² Uâ€²
ğ¸ ğ¸
UU U Uğ¸ ğ¸
U UUâ€² Uâ€²
U U
â–¡
55
2696
2697
2698
2699
2700
2701
2702
2703
2704
2705
2706
2707
2708
2709
2710
2711
2712
2713
2714
2715
2716
2717
2718
2719
2720
2721
2722
2723
2724
2725
2726
2727
2728
2729
2730
2731
2732
2733
2734
2735
2736
2737
2738
2739
2740
2741
2742
2743
2744
In submission, March 2023,
Augustsson, Breitner, Claessen, Jhala, Peyton Jones, Shivers, Steele, Sweeney
Lemma C.46. Let Uâ€² = U + exi-swap. If ğ‘’ âˆ’â†’â†’Uâ€² ğ‘’â€² there exists ğ‘’â€²â€² such that ğ‘’â€² âˆ’â†’â†’U ğ‘’â€²â€² and
ğ‘’ âˆ’â†’â†’exi-swap Â· âˆ’â†’â†’U ğ‘’â€²â€².
ğ‘’ ğ‘’â€²
â€¢ ğ‘’â€²â€²
exi-swap
U
U
Uâ€²
Proof. (Similar to Lemma C.36), By using Lemma B.25 with the facts that U is confluent
(Lemma C.19) and U hops after exi-swap (Lemma C.37). â–¡
Lemma C.47. Let Uâ€² = U + exi-swap. Uâ€™ commutes with U.
Proof. The proof follows by observing that U half-commutes with exi-swap Lemma C.48, recall-
ing that U is confluent Lemma C.19, after which Lemma B.27 yields the conclusion U commutes
with U + exi-swap â‰¡ Uâ€². â–¡
Lemma C.48. U half-commutes with exi-swap.
Proof. Same as Lemma C.41; the rules in Uother than those in the subset SS trivially half-
commutes as they do not overlap with exi-swap. â–¡
C.7 U âˆª N Commute With A âˆª G âˆª C
Lemma C.49 (U-A-Comm). U and A commute.
Proof. We show that U âˆ—-commutes with A and hence commutes via Lemma B.34. Let Î”U âˆ’â†’U
Î”â€²
U and Î”A âˆ’â†’A Î”â€²
A denote the reducts for U and A respectively.
Case: Î”U and Î”A disjoint via Lemma C.4.
Case: Î”U âŠ† Î”A via Lemma C.5.
Case: Î”A âŠ† Î”U via Lemma C.6.
â–¡
Lemma C.50 (U âˆ’ G-Comm). U and G commute.
Proof. We show that U âˆ—-commutes commutes wth G, and hence by Lemma B.34, U commutes
wth G. Let Î”U âˆ’â†’U Î”â€²
U and Î”G âˆ’â†’G Î”â€²
G denote the reducts for U and G respectively. If the reducts
are disjoint then terms can be trivially joined. Let us split cases on whether Î”U occurs under Î”G
or vice versa.
Case Î”U âŠ† Î”G : via Lemma C.9.
Case Î”G âŠ† Î”U : via Lemma C.6.
â–¡
Lemma C.51 (U âˆ’ C-Comm). U and C commute.
Proof. We show that U âˆ—-commutes with C, and hence by Lemma B.34, U commutes wth C.
Let Î”U âˆ’â†’U Î”â€²
U and Î”C âˆ’â†’C Î”â€²
C denote the reducts for U and C respectively. If the reducts are
disjoint then terms can be trivially joined. Let us split cases on whether Î”U occurs under Î”C or
vice versa.
Case Î”U âŠ† Î”C via Lemma C.10.
Case Î”C âŠ† Î”U via Lemma C.6.
â–¡
Lemma C.52. N and A commute.
56
2745
2746
2747
2748
2749
2750
2751
2752
2753
2754
2755
2756
2757
2758
2759
2760
2761
2762
2763
2764
2765
2766
2767
2768
2769
2770
2771
2772
2773
2774
2775
2776
2777
2778
2779
2780
2781
2782
2783
2784
2785
2786
2787
2788
2789
2790
2791
2792
2793
The Verse Calculus: a Core Calculus for Functional Logic Programming
In submission, March 2023,
Proof. We show that N strongly commutes with A, hence commutes via Lemma B.19. Let
Î”A âˆ’â†’A Î”â€²
A and Î”N âˆ’â†’N Î”â€²
N denote the reducts for A and N respectively. If the reducts are
disjoint then terms can be trivially joined in a single step. Let us split cases on whether Î”A occurs
under Î”N or vice versa.
Case Î”A âŠ† Î”N via Lemma C.8.
Case Î”N âŠ† Î”A via Lemma C.5.
â–¡
Lemma C.53. N and G commute.
Proof. We show that N strongly commutes with G, hence commutes via Lemma B.19. Let
Î”G âˆ’â†’G Î”â€²
G and Î”N âˆ’â†’N Î”â€²
N denote the reducts for G and N respectively. If the reducts are disjoint
then terms can be trivially joined in a single step. Let us split cases on whether Î”G occurs under
Î”N or vice versa.
Case Î”G âŠ† Î”N via Lemma C.8.
Case Î”N âŠ† Î”G via Lemma C.9.
â–¡
Lemma C.54. N and C commute.
Proof. We show that N strongly commutes with C, hence commutes via Lemma B.19. Let
Î”C âˆ’â†’C Î”â€²
C and Î”N âˆ’â†’N Î”â€²
N denote the reducts for C and N respectively. If the reducts are disjoint
then terms can be trivially joined in a single step. Split cases on whether Î”C occurs under Î”N or
vice versa.
Case Î”C âŠ† Î”N via Lemma C.8.
Case Î”N âŠ† Î”C via Lemma C.10.
â–¡
C.8 Application
Lemma C.55. A is confluent.
Proof. We show that A satisfies the diamond property and hence, is confluent by Lemma B.10.
Suppose that ğ‘’ âˆ’â†’A ğ‘’1 via the redux Î”1 âˆ’â†’A Î”â€²
1, and ğ‘’ âˆ’â†’A ğ‘’2 via the redux Î”2 âˆ’â†’A Î”â€²
2. If Î”1 and Î”2
are disjoint in ğ‘’, the terms ğ‘’1 and ğ‘’2 can be trivially joined in a single step. If Î”1 âŠ† Î”2 (or Î”2 âŠ† Î”1)
then Lemma C.5 completes the proof. â–¡
Lemma C.56. A and G commute.
Proof. We show that A strongly commutes with G, hence commutes via Lemma B.19. Let
Î”A âˆ’â†’A Î”â€²
A and Î”G âˆ’â†’G Î”â€²
G denote the reducts for A and G respectively. If the reducts are
disjoint then terms can be trivially joined in a single step. Let us split cases on whether Î”A occurs
under Î”N or vice versa.
Case Î”A âŠ† Î”G via Lemma C.9.
Case Î”G âŠ† Î”A via Lemma C.5.
â–¡
Lemma C.57. A and C commute.
Proof. We show that A strongly commutes with C, hence commutes via Lemma B.19. Let
Î”A âˆ’â†’A Î”â€²
A and Î”C âˆ’â†’C Î”â€²
C denote the reducts for A and C respectively. If the reducts are disjoin


3235
3236
3237
3238
3239
3240
3241
3242
3243
3244
3245
3246
3247
3248
3249
3250
3251
3252
3253
3254
3255
3256
3257
3258
3259
3260
3261
3262
3263
3264
3265
3266
3267
3268
3269
3270
3271
3272
3273
3274
3275
3276
3277
3278
3279
3280
3281
3282
3283
The Verse Calculus: a Core Calculus for Functional Logic Programming
In submission, March 2023,
Proof. â–¡
D.8 Proof that VC Is Skew Confluent
[This is just a brief proof sketch.]
First prove that the modified U is skew confluent. (In doing so we will define Uâ†
â©½ğœ”VC
.)
Then use existing proofs to demonstrate that A âˆª N âˆª G âˆª C is confluent. Because they are also
monotonic, they are therefore skew confluent, and (A âˆª N âˆª G âˆª C)â†
â©½ğœ”VC
is trivial.
Prove that A âˆª N âˆª G âˆª C commutes with Uâ†
â©½ğœ”VC
.
Then apply Lemma D.14 to show that U âˆª (A âˆª N âˆª G âˆª C) is skew confluent.
67
3284
3285
3286
3287
3288
3289
3290
3291
3292
3293
3294
3295
3296
3297
3298
3299
3300
3301
3302
3303
3304
3305
3306
3307
3308
3309
3310
3311
3312
3313
3314
3315
3316
3317
3318
3319
3320
3321
3322
3323
3324
3325
3326
3327
3328
3329
3330
3331
3332
In submission, March 2023,
Augustsson, Breitner, Claessen, Jhala, Peyton Jones, Shivers, Steele, Sweeney
Domains
ğ‘Š = Z + âŸ¨ğ‘Š âŸ© + (ğ‘Š â†’ ğ‘Š âˆ—)
âŸ¨ğ‘Š âŸ© = a finite tuple of values ğ‘Š
ğ¸ğ‘›ğ‘£ = ğ¼ğ‘‘ğ‘’ğ‘›ğ‘¡ â†’ ğ‘Š
Semantics of expressions and values
EJeK : ğ¸ğ‘›ğ‘£ â†’ ğ‘Š âˆ—
EJvK ğœŒ = unit (VJğ‘£K ğœŒ)
EJfailK ğœŒ = empty
EJe1 e2K ğœŒ = EJe1K ğœŒ â‹“ EJe2K ğœŒ
EJe1 = e2K ğœŒ = EJe1K ğœŒ â‹’ EJe2K ğœŒ
EJe1; e2K ğœŒ = EJe1K ğœŒ # EJe2K ğœŒ
EJv1 v2K ğœŒ = apply(VJv1K ğœŒ, VJv2K ğœŒ)
EJâˆƒx. eK ğœŒ = Ãğ‘¤ âˆˆğ‘Š EJğ‘’K (ğœŒ [ğ‘¥ â†¦ â†’ ğ‘¤])
EJone{e}K ğœŒ = one(EJğ‘’K ğœŒ)
EJall{e}K ğœŒ = unit (all(EJğ‘’K ğœŒ))
VJvK : ğ¸ğ‘›ğ‘£ â†’ ğ‘Š
VJxK ğœŒ = ğœŒ (ğ‘¥)
VJkK ğœŒ = ğ‘˜
VJğ‘œğ‘K ğœŒ = OJğ‘œğ‘K
VJğœ†x. eK ğœŒ = ğœ†ğ‘¤ .EJğ‘’K (ğœŒ [ğ‘¥ â†¦ â†’ ğ‘¤])
VJâŸ¨v1, Â·Â·Â·, vnâŸ©K ğœŒ = âŸ¨VJğ‘£1K ğœŒ, Â·Â·Â·, VJğ‘£ğ‘› K ğœŒâŸ©
OJopK : ğ‘Š
OJaddK = ğœ†ğ‘¤ . if (ğ‘¤ = âŸ¨k1, k2âŸ©) then unit (ğ‘˜1 + ğ‘˜2) else WRONG
OJgtK = ğœ†ğ‘¤ . if (ğ‘¤ = âŸ¨k1, k2âŸ© âˆ§ ğ‘˜1 > ğ‘˜2) then unit (ğ‘˜1) else empty
OJintK = ğœ†ğ‘¤ . if (ğ‘¤ = ğ‘˜) then unit (ğ‘˜) else empty
ğ‘ğ‘ğ‘ğ‘™ğ‘¦ : (ğ‘Š Ã— ğ‘Š ) â†’ ğ‘Š âˆ—
ğ‘ğ‘ğ‘ğ‘™ğ‘¦(ğ‘˜, ğ‘¤) = WRONG ğ‘˜ âˆˆ Z
ğ‘ğ‘ğ‘ğ‘™ğ‘¦(âŸ¨ğ‘£0, Â·Â·Â·, ğ‘£ğ‘› âŸ©, ğ‘˜) = unit (ğ‘£ğ‘˜ ) 0 â©½ ğ‘˜ â©½ ğ‘›
= empty otherwise
ğ‘ğ‘ğ‘ğ‘™ğ‘¦(ğ‘“ , ğ‘¤) = ğ‘“ (ğ‘¤) ğ‘“ âˆˆ ğ‘Š â†’ ğ‘Š âˆ—
Fig. 19. Expression semantics
E A DENOTATIONAL SEMANTICS FOR VC
It is highly desirable to have a denotational semantics for VC. A denotational semantics says
directly what an expression means rather than how it behaves, and that meaning can be very
perspicuous. Equipped with a denotational semantics we can, for example, prove that the left hand
side and right hand side of each rewrite rule have the same denotation; that is, the rewrites are
meaning-preserving.
68
3333
3334
3335
3336
3337
3338
3339
3340
3341
3342
3343
3344
3345
3346
3347
3348
3349
3350
3351
3352
3353
3354
3355
3356
3357
3358
3359
3360
3361
3362
3363
3364
3365
3366
3367
3368
3369
3370
3371
3372
3373
3374
3375
3376
3377
3378
3379
3380
3381
The Verse Calculus: a Core Calculus for Functional Logic Programming
In submission, March 2023,
Domains
ğ‘Š âˆ— = (WRONG + P (ğ‘Š ))âŠ¥
Operations
Empty empty : ğ‘Š âˆ—
empty = { }
Unit unit : ğ‘Š â†’ ğ‘Š âˆ—
unit (ğ‘¤) = {ğ‘¤ }
Union â‹“ : ğ‘Š âˆ— â†’ ğ‘Š âˆ— â†’ ğ‘Š âˆ—
ğ‘ 1 â‹“ ğ‘ 2 = ğ‘ 1 âˆª ğ‘ 2
Intersection â‹’ : ğ‘Š âˆ— â†’ ğ‘Š âˆ— â†’ ğ‘Š âˆ—
ğ‘ 1 â‹’ ğ‘ 2 = ğ‘ 1 âˆ© ğ‘ 2
Sequencing # : ğ‘Š âˆ— â†’ ğ‘Š âˆ— â†’ ğ‘Š âˆ—
ğ‘ 1 # ğ‘ 2 = ğ‘ 2 if ğ‘ 1 is non-empty
= { } otherwise
One one : ğ‘Š âˆ— â†’ ğ‘Š âˆ— The result is either empty or a singleton
one(ğ‘ ) = ???
All all : ğ‘Š âˆ— â†’ âŸ¨ğ‘Š âŸ©
all(ğ‘ ) = ???
All operations over ğ‘Š âˆ— implicitly propagate âŠ¥ and WRONG. E.g.
ğ‘ 1 â‹“ ğ‘ 2 = âŠ¥ if ğ‘ 1 = âŠ¥ or ğ‘ 2 = âŠ¥
= WRONG if (ğ‘ 1 = WRONG and ğ‘ 2 â‰  âŠ¥) or (ğ‘ 2 = WRONG and ğ‘ 1 â‰  âŠ¥)
= ğ‘ 1 âˆª ğ‘ 2 otherwise
Fig. 20. Set semantics for ğ‘Š âˆ—
But a denotational semantics for a functional logic language is tricky. Typically one writes a
denotation function something like
EJeK : ğ¸ğ‘›ğ‘£ â†’ ğ‘Š
where ğ¸ğ‘›ğ‘£ = ğ¼ğ‘‘ğ‘’ğ‘›ğ‘¡ â†’ ğ‘Š . So E takes an expession e and an environment ğœŒ : ğ¸ğ‘›ğ‘£ and returns the
value, or denotation, of the expresssion. The environment binds each free variable of e to its value.
But what is the semantics of âˆƒx. e? We need to extend ğœŒ with a binding for x, but what is x bound
to? In a functional logic language x is given its value by various equalities scattered throughout e.
This section sketches our approach to this challenge. It is not finished work, and does not count
as a contribution of our paper. We offer it because we have found it an illuminating alternative way
to understand VC, one that complements the rewrite rules that are the substance of the paper.
E.1 A first attempt at a denotational semantics
Our denotational semantics for VC is given in Fig. 19.
â€¢ We have one semantic function (here E and V) for each syntactic non terminal (here ğ‘’ and ğ‘£
respectively.)
â€¢ Each function has one equation for each form of the construct.
69
3382
3383
3384
3385
3386
3387
3388
3389
3390
3391
3392
3393
3394
3395
3396
3397
3398
3399
3400
3401
3402
3403
3404
3405
3406
3407
3408
3409
3410
3411
3412
3413
3414
3415
3416
3417
3418
3419
3420
3421
3422
3423
3424
3425
3426
3427
3428
3429
3430
In submission, March 2023,
Augustsson, Breitner, Claessen, Jhala, Peyton Jones, Shivers, Steele, Sweeney
â€¢ Both functions take an environment ğœŒ that maps in-scope identifiers to a single value; see
the definition ğ¸ğ‘›ğ‘£ = ğ¼ğ‘‘ğ‘’ğ‘›ğ‘¡ â†’ ğ‘Š .
â€¢ The value function V returns a single value ğ‘Š , while the expression function E returns a
collection of values ğ‘Š âˆ— (Appendix E.1).
The semantics is parameterised over the meaning of a â€œcollection of values ğ‘Š âˆ—â€. To a first
approximation, think of ğ‘Š âˆ— a (possibly infinite) set of values ğ‘Š , with union, intersection etc having
their ordinary meaning.
Our first interpretation, given in Figure 20, is a little more refined: ğ‘Š âˆ— includes âŠ¥ and WRONG as
well as a set of values. Our second interpretation is given in Figure 21, and discussed in Appendix E.4.
The equations themselves, in Fig. 19 are beautifully simple and compositional, as a denotational
semantics should be.
The equations for V are mostly self-explanatory, but an equation like VJkK ğœŒ = ğ‘˜ needs some
explanation: the ğ‘˜ on the left hand side (e.g. â€œ3â€) is a piece of syntax, but the ğ‘˜ on the right is
the corresponding element of the semantic world of values ğ‘Š (e.g. 3). As is conventional, albeit
a bit confusing, we use the same ğ‘˜ for both. Same for ğ‘œğ‘, where the semantic equivalent is the
corresponding mathematical function.
The equations for E are more interesting.
â€¢ Values EJvK ğœŒ: compute the single value for v, and return a singleton sequence of results.
The auxiliary function unit is defined at the bottom of Fig. 19.
â€¢ In particular, values include lambdas. The semantics says that a lambda evaluates to a singleton
collection, whose only element is a function value. But that function value has type ğ‘Š â†’ ğ‘Š âˆ—;
that is, it is a function that takes a single value and returns a collection of values.
â€¢ Function application EJv1 v2K ğœŒ is easy, because V returns a single value: just apply the
meaning of the function to the meaning of the argument. The apply function is defined in
Figure 19.
â€¢ Choice EJe1 e2K ğœŒ: take the union (written â‹“) of the values returned by e1 and e2 respectively.
For bags this union operator is just bag union (Figure 20).
â€¢ Unification EJe1 e2K ğœŒ: take the intersection of the values returned by e1 and e2 respectively.
For bags, this â€œintersectionâ€ operator â‹’ is defined in Fig. 20. In this definition, the equality is
mathematical equality of functions; which we canâ€™t implement for functions; see Appendix E.1.
â€¢ Sequencing EJe1; e2K ğœŒ. Again we use an auxiliary function # to combine the meanings of
e1 and e2. For bags, the function # (Fig. 20 again) uses a bag comprehension. Again it does a
cartesian product, but without the equality constraint of â‹’.
â€¢ The semantics of (one{e}) simply applies the semantic function one : ğ‘Š âˆ— â†’ ğ‘Š âˆ— to the
collection of values returned by e. If e returns no values, so does (one{e}); but if e returns one
or more values, (one{e}) returns the first. Of course that begs the question of what â€œthe firstâ€
means â€“ for bags it would be non-deterministic. We will fix this problem in Appendix E.4,
but for now we simply ignore it.
â€¢ The semantics of (all{e}) is similar, but it always returns a singleton collection (hence the
unit in the semantics of all) whose element is a (possibly-empty) tuple that contains all the
values in the collection returned by e.
The fact that unification â€œ=â€ maps onto intersection, and choice â€œ â€ onto union, is very satisfying.
The big excitement is the treatment of âˆƒ. We must extend ğœŒ, but what should we bind x to?
(Compare the equation for VJğœ†x. eK , where we have a value ğ‘¤ to hand.) Our answer is simple: try
all possible values, and union the results:
EJâˆƒx. eK ğœŒ =
Ã˜
ğ‘¤ âˆˆğ‘Š
EJğ‘’K (ğœŒ [ğ‘¥ â†¦ â†’ ğ‘¤])
70
3431
3432
3433
3434
3435
3436
3437
3438
3439
3440
3441
3442
3443
3444
3445
3446
3447
3448
3449
3450
3451
3452
3453
3454
3455
3456
3457
3458
3459
3460
3461
3462
3463
3464
3465
3466
3467
3468
3469
3470
3471
3472
3473
3474
3475
3476
3477
3478
3479
The Verse Calculus: a Core Calculus for Functional Logic Programming
In submission, March 2023,
That Ãğ‘¤ âˆˆğ‘Š means: enumerate all values in ğ‘¤ âˆˆ ğ‘Š , in some arbitrary order, and for each: bind ğ‘¥ to
ğ‘¤, find the semantics of ğ‘’ for that value of ğ‘¥, namely EJğ‘’K (ğœŒ [ğ‘¥ â†¦ â†’ ğ‘¤]), and take the union (in the
sense of â‹“) of the results.
Of course we canâ€™t possibly implement it like this, but it makes a great specification. For example
âˆƒx. x = 3 tries all possible values for x, but only one of them succeeds, namely 3, so the semantics
is a singleton sequence [3].
E.2 The denotational semantics is un-implementable
This semantics is nice and simple, but we definitely canâ€™t implement it! Consider
âˆƒx. (x2 âˆ’ x âˆ’ 6) = 0; x
The semantics will iterate over all possible values for x, returning all those that satisfy the equality;
including 3, for example. But unless our implementation can guarantee to solve quadratic equations,
we canâ€™t expect it to return 3. Instead itâ€™ll get stuck.
Another way in which the implementation might get stuck is through unifying functions:
(ğœ†x. x + x) = (ğœ†y. y âˆ— 2) or even (ğœ†x. x + 1) = (ğœ†y. y + 1)
But not all unification-over-functions is ruled out. We do expect the implementation to succeed
with
âˆƒf . ((ğœ†x. x + 1) = f ); f 3
Here the âˆƒ will â€œiterateâ€ over all values of f , and the equality will pick out the (unique) iteration in
which f is bound to the incrementing function.
So our touchstone must be:
â€¢ If the implementation returns a value at all, it must be the value given by the semantics.
â€¢ Ideally, the verifier will guarantee that the implementation does not get stuck, or go WRONG.
E.3 Getting WRONG right
Getting WRONG right is a bit tricky.
â€¢ What is the value of (3 = âŸ¨âŸ©)? The intersection semantics would say empty, the empty
collection of results, but we might want to say WRONG.
â€¢ Should WRONG be an element of ğ‘Š or of ğ‘Š âˆ—? We probably want (one{3 wrong} to return
a unit (3) rather then WRONG?
â€¢ What about fst (âŸ¨3, wrongâŸ©)? Is that wrong or 3?
There is probably more than one possible choice here.
E.4 An order-sensitive denotational semantics
There is a Big Problem with this approach. Consider âˆƒx. x = (4 3). The existential enumerates
all possible values of x in some arbitrary order, and takes the union (i.e., â€œconcatentationâ€) of the
results from each of these bindings. Suppose that âˆƒ enumerates 3 before 4; then the semantics of
this expression is the sequence [3, 4], and not [4, 3] as it should be. And yet returning a sequence
(not a set nor a bag) is a key design choice in Verse. What can we do?
Figure 21 give a new denotational semantics that does account for order. The key idea (due to
Joachim Breitner) is this: return a sequence of labelled values; and then sort that sequence (in one
and all) into canonical order before exposing it to the programmer.
We do not change the equations for E, V, and O at all; they remain precisely as they are in
Figure 19. However the semantics of a collection of values, ğ‘Š âˆ—, does change, and is given in
Figure 21:
71
3480
3481
3482
3483
3484
3485
3486
3487
3488
3489
3490
3491
3492
3493
3494
3495
3496
3497
3498
3499
3500
3501
3502
3503
3504
3505
3506
3507
3508
3509
3510
3511
3512
3513
3514
3515
3516
3517
3518
3519
3520
3521
3522
3523
3524
3525
3526
3527
3528
In submission, March 2023,
Augustsson, Breitner, Claessen, Jhala, Peyton Jones, Shivers, Steele, Sweeney
Domains
ğ‘Š âˆ— = (WRONG + P (ğ¿ğ‘Š ))âŠ¥
ğ‘Š ? = {ğ‘Š } Set with 0 or 1 elements
ğ¿ğ‘Š = [ğ¿] Ã— ğ‘Š Sequence of ğ¿ and a value
ğ¿ = L + R
Operations
Empty empty : ğ‘Š âˆ—
empty = âˆ…
Singleton unit : ğ‘Š â†’ ğ‘Š âˆ—
unit (ğ‘¤) = {([], ğ‘¤)}
Union â‹“ : ğ‘Š âˆ— â†’ ğ‘Š âˆ— â†’ ğ‘Š âˆ—
ğ‘ 1 â‹“ ğ‘ 2 = {(L : ğ‘™, ğ‘¤) | (ğ‘™, ğ‘¤) âˆˆ ğ‘ 1 } âˆª {(R : ğ‘™, ğ‘¤) | (ğ‘™, ğ‘¤) âˆˆ ğ‘ 2 }
Intersection â‹’ : ğ‘Š âˆ— â†’ ğ‘Š âˆ— â†’ ğ‘Š âˆ—
ğ‘ 1 â‹’ ğ‘ 2 = {(ğ‘™1 âŠ²âŠ³ ğ‘™2, ğ‘¤1) | (ğ‘™1, ğ‘¤1) âˆˆ ğ‘ 1, (ğ‘™2, ğ‘¤2) âˆˆ ğ‘ 2, ğ‘¤1 = ğ‘¤2 }
Sequencing # : ğ‘Š âˆ— â†’ ğ‘Š âˆ— â†’ ğ‘Š âˆ—
ğ‘ 1 # ğ‘ 2 = {(ğ‘™1 âŠ²âŠ³ ğ‘™2, ğ‘¤2) | (ğ‘™1, ğ‘¤1) âˆˆ ğ‘ 1, (ğ‘™2, ğ‘¤2) âˆˆ ğ‘ 2 }
One one : ğ‘Š âˆ— â†’ ğ‘Š âˆ—
one(ğ‘ ) = head (sort (ğ‘ ))
All all : ğ‘Š âˆ— â†’ ğ‘Š âˆ—
all(ğ‘ ) = tuple(sort (ğ‘ ))
Head head : ([ğ‘Š ] + WRONG) â†’ ğ‘Š âˆ—
head (WRONG) = WRONG
head [] = ğ‘’ğ‘šğ‘ğ‘¡ğ‘¦
head (ğ‘¤ : ğ‘ ) = unit (ğ‘¤)
To tuple tuple : ([ğ‘Š ] + WRONG) â†’ âŸ¨ğ‘Š âŸ©
tuple(WRONG) = WRONG
tuple[ğ‘¤1, Â·Â·Â·, ğ‘¤ğ‘› ] = âŸ¨ğ‘¤1, Â·Â·Â·, ğ‘¤ğ‘› âŸ©
Sort sort : ğ¿ğ‘Š âˆ— â†’ ([ğ‘Š ] + WRONG)âŠ¥
sort (ğ‘ ) = [] if ğ‘  is empty
= WRONG if ğ‘¤ğ‘  has more than one element
= ğ‘¤ğ‘  otherwise
âŠ²âŠ³ sort{(ğ‘™, ğ‘¤) | (L : ğ‘™, ğ‘¤) âˆˆ ğ‘ }
âŠ²âŠ³ sort{(ğ‘™, ğ‘¤) | (R : ğ‘™, ğ‘¤) âˆˆ ğ‘ }
where ğ‘¤ğ‘  = [ğ‘¤ | ([], ğ‘¤) âˆˆ ğ‘ ]
Fig. 21. Labelled set semantics for ğ‘Š âˆ—
72
3529
3530
3531
3532
3533
3534
3535
3536
3537
3538
3539
3540
3541
3542
3543
3544
3545
3546
3547
3548
3549
3550
3551
3552
3553
3554
3555
3556
3557
3558
3559
3560
3561
3562
3563
3564
3565
3566
3567
3568
3569
3570
3571
3572
3573
3574
3575
3576
3577
The Verse Calculus: a Core Calculus for Functional Logic Programming
In submission, March 2023,
â€¢ A collection of values ğ‘Š âˆ— is now âŠ¥ or WRONG (as before), or a set of labelled values, each of
type ğ¿ğ‘Š .
â€¢ A labelled value (of type ğ¿ğ‘Š ) is just a pair ([ğ¿] Ã— ğ‘Š ) of a label and a value.
â€¢ A label is a sequence of tags ğ¿, where a tag is just L or R, similar to Section 5.1.
â€¢ The union (or concatentation) operation â‹“, defined in Fig. 21, adds a L tag to the labels of the
values in the left branch of the choice, and a R tag to those coming from the right. So the
labels specify where in the tree the value comes from.
â€¢ Sequencing # and â‹’ both concatenate the labels from the values they combine.
â€¢ Finally sort puts everything in the â€œrightâ€ order: first the values with an empty label, then the
values whose label starts with L (notice the recursive sort of the trimmed-down sequence),
and then those that start with R. Notice that sort removes all the labels, leaving just a bare
sequence of values ğ‘Š âˆ—.
â€¢ Note that if sort encounters a set with more than one unlabelled element then this considered
WRONG. This makes ambiguous expressions, like one{âˆƒx. x}, WRONG.
Let us look at our troublesome example âˆƒx. x = (4 3), and assume that âˆƒ binds x to 3 and then 4.
The meaning of this expression will be
EJâˆƒx. x = (4 3)K ğœ– = [(R, 3), (L, 4)]
Now if we take all of that expression we will get a singleton sequence containing âŸ¨4, 3âŸ©, because
all does a sort, stripping off all the tags.
EJall{âˆƒx. x = (4 3)}K ğœ– = [([], âŸ¨4, 3âŸ©)]
E.5 Related work
[Christiansen et al . 2011] gives another approach to a denotational semantics for a functional logic
language. We are keen to learn of others.
73
3578
3579
3580
3581
3582
3583
3584
3585
3586
3587
3588
3589
3590
3591
3592
3593
3594
3595
3596
3597
3598
3599
3600
3601
3602
3603
3604
3605
3606
3607
3608
3609
3610
3611
3612
3613
3614
3615
3616
3617
3618
3619
3620
3621
3622
3623
3624
3625
3626
In submission, March 2023,
Augustsson, Breitner, Claessen, Jhala, Peyton Jones, Shivers, Steele, Sweeney
F UPDATEABLE REFERENCES
The full Verse language has updatable references (Ã  la ML). There are three new primitive operations,
alloc, read, and write. The alloc creates a new reference with an initial value, read extracts the
value from a reference, and write sets the value of a referene.
Modifying these references is transactional in the sense that if a computation fails, then any
updates will not be visible outside the construct that handles the failures. E.g.,
r B alloc(0); (if (writeâŸ¨r, 1âŸ©; fail) then 1 else 2); read(r)
will have the value 0, because the write is part of an expression that fails, and so its effect is not
visible.
To add updateable references we extend the system with syntax and rules from figure 22. The
store h in {e} indicates that e should be reduced using the heap h. A heap is simply a mapping from
references to values (one mapping being r â†¦ â†’ v). A reference is some opaque type that supports
equality (unification) and creation of a new reference.
The interaction of the new primitives with the store can be seen from the axioms. The alloc(v)
operation creates a new reference and adds a binding with v to the store. The read(r) operation
retrieves the value for reference r from the store, and writeâŸ¨r, vâŸ© updates the reference r with v in
the store. All of these operations use the context S which ensures that there are no store operations
to the left of the hole, i.e., a store operation in the hole is the next one that should execute.
The interesting rules involve choice and split because store operations are transactional in the
sense that when an expressions fails, none of its store operations will happen.
When reducing split(e){f , g} in an S hole, rule st-split-dup, the store is duplicated. Any store
operations inside the split will happen in this local copy of the store. Note the two occurrences
of h in the right hand side of st-split-dup. If the reduction of e results in fail then rule fail-elim
is used, and the store from the failing computation is simply thrown away. If the reduction of e
results in a value (with or without more alternatives) then rule st-split is used. This rule replaces
the outer store with the inner store, since we know the inner computation has succeeded.
Similarely, the reduction of e1 e2 will duplicate the store into the first branch, st-choice-dup.
Here e1 must not contain any store operation nor be a value. And again, similarely, st-choice
commits the new store and throws away the old.
The use of oe in the rules is to ensure that the rules cannot get stuck in a loop. Using e instead of
oe would mean that failing or committing would make the expression match the duplication rule
again. It also prevents the duplication rule from repeatedly duplicating the store.
Note that store is part of the ğ‘‹ context, which means that the store can float inside existentials.
This is necessary for the store rules to fire since the S context does not allow going under existentials.
The semantics of for(d) do e with respect to store effects is somewhat intricate. The expression
d is possibly multi-valued; any effects that happens when computing the first value of d will be
visible the first time e is computed. Both these effects are then visible when computing the second
value of d, and so on. If any iteration of d fails, then the effects of that computation are not visible
outside d. This means that the desugaring of for into split needs to be more elaborate.
for(âˆƒx1Â·Â·Â·xn. d) do e
means
f âŸ¨âŸ© B âŸ¨âŸ©;
g(v)(r) B (v = âŸ¨x1, Â·Â·Â·, xnâŸ©; consâŸ¨e, split(r âŸ¨âŸ©){f , g}âŸ©;
split(âˆƒx1 Â·Â·Â· xn. d; âŸ¨x1, Â·Â·Â·, xnâŸ©){f , g}
To support limited store operations (e.g., read, but not write) we can equip the store with a set
of currently allowed operations. We also need some extra primitives that modify this set.
74
3627
3628
3629
3630
3631
3632
3633
3634
3635
3636
3637
3638
3639
3640
3641
3642
3643
3644
3645
3646
3647
3648
3649
3650
3651
3652
3653
3654
3655
3656
3657
3658
3659
3660
3661
3662
3663
3664
3665
3666
3667
3668
3669
3670
3671
3672
3673
3674
3675
The Verse Calculus: a Core Calculus for Functional Logic Programming
In submission, March 2023,
Syntax extension
References ğ‘Ÿ
Expressions ğ‘’ ::= Â· Â· Â· | store h in {e}
Primops ğ‘œğ‘ ::= Â· Â· Â· | alloc | read | write
Head values â„ğ‘›ğ‘“ ::= Â· Â· Â· | ğ‘Ÿ
Execution contexts ğ‘‹ ::= Â· Â· Â· | store h in {ğ‘‹ }
Scope contexts ğ‘†ğ¶ ::= Â· Â· Â· | store h in {SC}
Heap â„ ::= ğœ– | r â†¦ â†’ v, h
Heap context ğ» ::= â–¡, h | r â†¦ â†’ v, H
Store contexts ğ‘† ::= â–¡ | v = S | S; e | ğ‘ ğ‘’; S | âˆƒx. S
Store-op free exprs ğ‘ ğ‘’ ::= v | ğ‘ ğ‘’1 = ğ‘ ğ‘’2 | ğ‘ ğ‘’1; ğ‘ ğ‘’2 | âˆƒx. ğ‘ ğ‘’ | sp(v)
Results ğ‘¤ ::= v | v e
Non-store primops ğ‘ ğ‘ ::= any, except alloc, read, write
Non-store expression ğ‘œğ‘’ ::= like e, but not w, store, or fail
Axiom extensions
Normalization change
exi-float ğ‘‹ [ âˆƒx. e ] âˆ’â†’ âˆƒx. ğ‘‹ [ e ] if ğ‘‹ â‰  â–¡, ğ‘¥ âˆ‰ fvs(ğ‘‹ ), use ğ›¼
if there is store in ğ‘‹ then e âˆˆ ce
Reference ops
ref-alloc store h in {S[ alloc(v) ]} âˆ’â†’ store r â†¦ â†’ v, h in {S[ r ]}
fvs(v)#bvs(S), r fresh
ref-read store H [ r â†¦ â†’ v ] in {S[ read(r) ]} âˆ’â†’ store H [ r â†¦ â†’ v ] in {S[ v ]}
fvs(v)#bvs(S), use ğ›¼
ref-write store H [ r â†¦ â†’ v1 ] in {S[ writeâŸ¨r, v2âŸ© ]} âˆ’â†’ store H [ r â†¦ â†’ v2 ] in {S[ âŸ¨âŸ© ]}
fvs(v2)#bvs(S)
Store duplication
st-split-dup store h in {S[ split(oe){f , g} ]} âˆ’â†’ store h in {S[ split(store h in {oe}){f , g} ]}
fvs(h)#bvs(S), use ğ›¼
st-choice-dup store h in {oe e} âˆ’â†’ store h in {store h in {oe} e}
Store commit
st-split store h1 in {S[ split(store h2 in {w}){f , g} ]} âˆ’â†’ store h2 in {S[ split(w){f , g} ]}
fvs(h2)#bvs(S)
st-choice store h1 in {S[ (store h2 in {w}) e ]} âˆ’â†’ store h2 in {S[ w e ]}
fvs(h2)#bvs(S)
Unification
Extension with the obvious axioms making equal references unify, and anything else fail.
Top level
Start top level reduction of e with store ğœ– in {e}.
